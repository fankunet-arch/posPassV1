CPSYS-B1-PASS-REVIEW-AND-PAYMENT-MINI 阶段完成报告
版本：v1.0
日期：2025-11-21
作者：TopTea 次卡 · 总体设计工程师（CTO 视角）
一、阶段背景
本阶段聚焦两个长期存在、但一直“没有真正落地”的问题：
1.次卡售卡审核逻辑形同虚设
oCPSYS 中配置了 auto_activate 字段和 Topup orders 审核流程，但 POS 端无论是否需要审核，生成的 member_passes 记录一律为 active，导致“未审核也能核销”。
2.次卡核销加价场景支付方式无限制
o用户在次卡核销时，如果有额外金额（extra_charge_total > 0），前端仍展示所有支付方式（含 Bizum、Platform 等），后端也不做校验。
目标：在不改数据库结构的前提下，用最小改动补齐审核链路与支付白名单，让现有配置真正生效。
二、次卡售卡审核链路修复
1.数据与现状
opass_plans.auto_activate：方案级配置，1 表示售出后自动激活，0 表示需要人工审核。
otopup_orders.review_status：次卡售卡订单的审核状态（pending / confirmed / rejected / refunded）。
omember_passes.status：枚举('active','suspended','revoked','expired')。
oPOS 核销逻辑仅认 status = 'active'。
o旧实现：create_pass_records() 在插入 member_passes 时硬编码 status='active'，完全无视 auto_activate。
2.设计与实现
o设计策略：
借用 member_passes.status='suspended' 作为“未审核/暂不可用”的语义，禁止修改 enum 结构。
通过 topup_orders.review_status + member_passes.status 组合表达“审核通过”的状态。
o实现要点：
1）POS 售卡（store_html/POS_backend/helpers/POS_pass_helper.php::create_pass_records）
从 $plan_details['auto_activate'] 读取配置（默认 1）。
INSERT 新卡时：
auto_activate = 1 → status = 'active'
auto_activate = 0 → status = 'suspended'（待审核，不可核销）
UPDATE 叠加购买时：
不再修改 status，只更新次数与金额，避免把已激活的卡整体打回 suspended。
2）CPSYS 审核（hq_html/app/helpers/kds/kds_repo_c.php::activate_member_pass）
复用原逻辑：INSERT ... oN DUPLICATE KEY UPDATE status='active'。
效果：只要总部审核通过，对应 member_passes 记录就会被强制设为 active。
3）POS 核销（store_html/POS_backend/helpers/POS_repo_ext_pass.php::get_member_pass_for_update）
沿用原有 WHERE status='active' 条件。
效果：未审核（suspended）的卡，在核销查询中直接被排除。
3.行为效果
oauto_activate=1 的方案：
POS 售卡后立即可核销，行为与旧版本一致。
oauto_activate=0 的方案：
售卡后生成 member_passes.status='suspended'，POS 无法核销。
总部在 CPSYS 审核通过后，status→active，POS 即可使用。
o已在用的老卡：
叠加购买不会把 active 变回 suspended，避免“误锁”。
4.注意事项（需写入系统说明）
o当前阶段，suspended 同时承担“未审核”和“人工冻结”两种语义。
o将来如果引入“真正的冻结原因”（如风控冻结），建议新增字段（例如 member_passes.suspend_reason）来区分具体原因，而不是再增加新的 status 值，以免破坏现有判断逻辑。
三、次卡核销支付渠道限制（加价场景）
1.问题回顾
o0 元核销：仅消耗次数，不产生现金流，无需特殊支付控制。
o有加价核销（extra_charge_total > 0）：存在实收金额，必须遵循“仅限现金/银行卡”规则。
o旧实现：
前端只在“购买优惠卡/次卡”时限制支付方式，核销场景完全没有限制。
后端仅检查金额是否足够，不校验支付方式类型。
2.前端限制（payment.js）
o核心逻辑（简化描述）：
计算：
若 STATE.purchasingDiscountCard ≠ null → 购卡模式。
若 STATE.activePassSession ≠ null 且 STATE.calculatedCart.final_total > 0 → 次卡核销有加价。
在以下任一条件满足时，只展示“现金 / 银行卡”：
正在购买优惠卡/次卡。
正在次卡核销且最终金额 > 0。
0 元核销（final_total = 0）保持原有支付方式展示逻辑，不做限制（B1 阶段不改 UX）。
3.后端白名单校验（POS_registry_ext_pass.php）
o使用 extract_payment_totals($payment_raw) 得到：
$cash：现金合计。
$card：银行卡合计。
$platform：所有第三方支付合计（Bizum、平台码、WeChat、Alipay 等）。
o在 calculate_redeem_allocation 得到 $alloc['extra_total'] 后：
若 extra_total = 0：
不做渠道校验，保持原逻辑。
若 extra_total > 0：
检查 $platform 是否 > 0.01。
若是 → 返回 400 错误："次卡核销加价只能使用现金或银行卡支付"，并附上各渠道金额，用于排查。
4.行为效果
o有加价核销：
前端：只能选现金/银行卡。
若前端被篡改，服务端仍会拦截包含第三方支付的请求。
o0 元核销：
行为与之前一致（仍走“支付弹窗 + 0 元支付”），只做了回归确认。
四、测试与验证
已按以下 5 个场景完成测试（测试脚本详见 Claude 报告）：
1.次卡售卡审核流程（auto_activate=0 时新卡必须审核后才能用）。
2.叠加购买不回退 status（active 卡不会因追加购买被锁死）。
3.前端限制：有加价核销时，仅显示现金/银行卡。
4.后端限制：伪造包含 Bizum/Platform 的支付请求会被 400 拦截，次数不会被扣减。
5.0 元核销回归：行为与改动前保持一致。
五、遗留问题与后续规划
1.叠加购买的审核精细化（待立项）
o目前：叠加购买永远沿用原 status，不触发新的“待审核”状态。
o未来可选方案：在 member_passes 中新增 pending_uses 字段，用于记录“审核通过后才生效的新增次数”。
2.0 元核销的 UX 优化（待立项）
o现状：0 元核销依然走完整的“选择支付方式 → 0 元支付”流程。
o建议：未来改为“选品 → 点击[核销] → 弹出确认框 → 直接完成核销”，不再走支付弹窗。
3.status 语义的进一步细化
o如前文所述，当系统引入风控冻结等场景时，应通过新增字段（如 suspend_reason）表达原因，而不是继续堆 status 枚举值。
阶段结论：
CPSYS-B1-PASS-REVIEW-AND-PAYMENT-MINI 阶段已完成。
次卡售卡审核与有加价核销的支付方式限制，均已按“最小改动、强约束”原则落地，并且通过了实测验证。

